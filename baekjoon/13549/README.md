# [gold5] 숨바꼭질3

[문제](https://www.acmicpc.net/problem/13549)

### 시간복잡도

- 단순 bfs로 구현할 경우 O(V+E): O(100001)이다.
- 단순 bfs로 문제를 해결 할 경우 +1/-1/\*2를 하며 중복되는 값이 늘어나 큐의 크기가 급격하게 커지며 시간 초과가 발생할 수 있다.

**제한사항**

- N(0 ≤ N ≤ 100,000)

### 문제풀이

<br>

- 1번: `dijkstra`을 통해 문제를 해결했다.

```
`MinHeap` 자료구조를 만들어 가중치 값이 제일 작은 것부터 정렬하며 넣어준다. 순간이동 하는 비용이 0 이기 때문에 이를 우선으로 처리 후 답을 찾아간다.
```

- 2번: `0-1bfs`을 통해 문제를 해결했다.

```
자바스크립트의 `unshift()`, `push()`메서드를 사용했다. 순간이동 할 경우 가중치가 0이기 때문에 `unshift()`, 걸어서 이동할 경우 `push()`을 통해 순간이동 할 때를 먼저 계산해 주었다.
```

### 정리

<br>

`0-1 bfs` 알고리즘은 **가중치가 0과 1 로만 주어진 그래프의 최단 경로를 찾을 경우 사용한다.** 다익스트라의 경우 O(ElogV) 시간복잡도가 걸리지만, `0-1bfs`의 경우 `O(V+E)`의 시간복잡도를 가진다.

**배운점**

**1. 직관적인 시간복잡도가 O(100001)이다. 왜 bfs로 풀지 못하는가?**

정확히는 V: 정점의수, E: 간선의 수 라고 할때, 최대 정점의 수는 100001이고, 간선의 수는 각 정점에 3개가 연결되어 있다고 가정했을 때(+1,-1,*2이기 때문에), O(100001+ 3*100001)이다. 따라서 왜 `bfs`로 풀지 못하는지 의문이었다. 하지만 **일반 bfs로 문제를 해결 할 경우 +1/-1/\*2을 순차적으로 찾기 때문에 K를 찾는 과정에서 중복되는 값을 계산할 수도 있으며 큐의 크기가 급격히 늘어난다**. 따라서, 해당 문제의 경우 `다익스트라 혹은 0-1bfs` 알고리즘을 통해 문제를 해결해야 한다.

**런타임에러**
