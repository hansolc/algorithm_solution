# [gold3] 움직이는 미로 탈출

[문제](https://www.acmicpc.net/problem/16954)

### 시간복잡도

- O(N^2)

**제한사항**

- 8개 줄에 걸쳐서 체스판의 상태가 주어진다. '.'은 빈 칸, '#'는 벽이다. 가장 왼쪽 아랫칸은 항상 벽이 아니다.

### 문제풀이

<br>

- `dfs`을 통해 문제를 해결했다.

```
재귀함수를 리턴하는 3가지 조건
1) 체스판을 벗어날 경우
2) 이동한 혹은 이동하려는 곳이 벽인 경우
3) 목적지에 도달 할 경우

그리고 `move`변수에 총 9가지 사용자의 이동 상태를 담은 배열을 담아 3가지 조건에 만족하는 경우만 재귀함수를 호출했다.
```

bfs/dfs중 하나를 고민했다. dfs을 선택한 이유는 백트랙킹을 사용하지 않고 벽의 상태를 어떻게 표현해야 좋을지 몰라 dfs을 선택했다.

### 정리

<br>

`dfs`보다 `bfs`알고리즘이 본 문제에서는 더 적합했다. 목적지 까지만 가면 해당 프로그램을 종료해도 되기 때문에 `bfs`가 더 적합하며 이동할 경우에도 무한루프에 빠지는 제한이 없다고 생각했다.

**배운점**

**1. dfs사용시 이동하는 방향에 따라 무한루프에 빠질수 있다**

처음 `move`변수는 [0,0]이 첫번재 인덱스로 가만히 있을 경우를 첫번째로 넘겨 주었다. 하지만 따로 제한이 없을 경우 1초,2초...,n초일 경우 까지 계속 가만히 있을 것이다. 따라서 `maximum call stack` 오류가 발생했다. 따라서, (오른쪽, 위, 대각선위)를 기준으로 먼저 이동 시켜 주어 해결했다.

**2. dfs을 사용할 경우 매번 이동시 `rollbackwall`함수를 매번 호출 해 오버해드가 크다**

위와 같은 이유로 bfs가 더 적합한 이유는 dfs로 문제를 해결할 경우 매 이동마다 벽을 변경해 주는 연산이 사용된다.

**bfs을 사용할 경우 가만히 있는 경우를 먼저 queue에 넣더라도 모든 이동이 보장되기 때문에 이동 우선순위에 신경을 쓸 필요가 없다**

**3. 8초까지 캐릭터가 벽에 갇히지 않는다면 종료 조건이다.**

벽은 8초후면 모두 사라진다. 따라서, 종료조건 중 하나인 캐릭터가 벽에 갇힐수 밖에 없는 상황이 아니라면 목적지에 도달할 수 있다.

`dfs`로 문제를 해결했지만 `bfs` 알고리즘에 해당 문제에 더 적합한 것을 배웠다.

**런타임에러**
