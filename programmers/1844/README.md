# [level:2] 게임 맵 최단거리

[문제](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

### 시간복잡도

<br>

**제한사항**

- maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
- maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
- 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.

### 문제풀이

<br>

`bfs`로 문제를 해결할 경우, 시간복잡도는 O(200^2) 정확히는 O(N \* M)인 40,000이다. 따라서 각 노드를 bfs로 순회하며 정답을 구했다.

### 정리

최단거리가 나왔을 때 `bfs`을 생각했다. `bfs` 함수에서 큐를 통해 문제를 해결했다.

<br>

**배운점**

**1. `shift()`메서드 대신 포인터 변수로**

JS에서 `queue`자료구조를 지원하지 않아 배열을 사용할 때 `shift()`메서드를 통해 풀었다. 하지만 성능을 개선하기 위해 `pointer` 변수를 선언해 `shift()`메서드를 대체할 수 있다는 것을 배웠다

- `pointer 변수` line17

1. `pointer`변수로 배열 맨 앞의 인덱스를 가리키는 값을 저장한다.
2. 루프 조건문에는 `pointer`변수가 기존 배열 `q`의 크기보다 커질 때, 즉, 더 이상 찾을 좌표가 없을 경우 탈출하게 한다. `pointer < q.length`

```
line 16 ~ 20
let pointer = 0

while(pointer < q.length) {
  const [nr, nc] = q[pointer++];
}
```

**2. 불필요한 조건**

line 23: `!maps[nr][nc]`

혹여나 1\*1맵에서 바로 장애물이 있고 `나`와 `상대편 진영` 이 겹칠 경우 바로 -1을 리턴해야 하거나 벽이 없을 경우 1을 return 해야 한다고 생각해 조건을 넣어줬다.

하지만 해당 조건을 빼도 벽이 없을 경우에는 정답이 되며, 오히려 벽이 있을 경우 1을 0을 return하기 때문에 문제가 된다고 본다

문제를 잘 통과한거 보니 해당 경우는 테케에 없었던것 같다.

**런타임에러**
